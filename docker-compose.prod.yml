services:
  backend:
    # Use the image built and pushed by the CI/CD pipeline
    # The actual image name will be sourced from the .env file on the VPS
    image: ${BACKEND_IMAGE_NAME}
    ports:
      # Expose FastAPI on host port 8000, container port 8000
      # Adjust if you have a reverse proxy like Nginx or Traefik on the VPS
      # that will handle incoming traffic and route to this service.
      # If so, you might not need to expose this port to the host directly.
      - "8000:8000"
    environment:
      # DATABASE_URL will be sourced from the .env file on the VPS
      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@db:5432/${DB_NAME}
      # Add any other production-specific backend environment variables here.
      # These can also be added to the .env file on the VPS.
      # Example:
      # - SECRET_KEY=${BACKEND_SECRET_KEY} # Assuming BACKEND_SECRET_KEY is in your .env
      # - ALGORITHM=${ALGORITHM}
      # - ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}
    depends_on:
      - db
    restart: unless-stopped
    networks:
      - app-network

  frontend:
    # Use the image built and pushed by the CI/CD pipeline
    # The actual image name will be sourced from the .env file on the VPS
    image: ${FRONTEND_IMAGE_NAME}
    ports:
      # Map host port 8080 to container port 80 (where Nginx inside the container listens)
      # Adjust if you have a reverse proxy on the VPS.
      # If a reverse proxy handles port 80/443, it would connect to this container
      # on port 80 over the app-network, and you might not expose this port to the host.
      - "8080:80"
    environment:
      # This tells the frontend running in the browser where to find the backend.
      # 'backend' is resolvable within the Docker network.
      # If your frontend needs to make requests from the client-side to an absolute URL
      # that is different in production (e.g., https://api.yourdomain.com),
      # you'll need to configure that build-time or run-time in your frontend app.
      # For now, assuming it calls http://backend:8000 which works if requests are proxied
      # or if the frontend is served from the same domain and proxies API requests.
      # If your Nginx in the frontend container is configured to proxy /api to the backend,
      # then VITE_BACKEND_URL might be set to /api or similar.
      # For simplicity, keeping as per your dev setup, assuming direct inter-container communication
      # or that your frontend Nginx handles this.
      - VITE_BACKEND_URL=http://backend:8000
    depends_on:
      - backend # Ensures backend is started, good for frontend making API calls.
    restart: unless-stopped
    networks:
      - app-network

  db:
    image: postgres:17 # Using a specific version of Postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data/ # Persistent data storage
    environment:
      # These will be sourced from the .env file on the VPS
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=${DB_NAME}
    # It's generally safer NOT to expose the database port directly to the host in production.
    # Services within the Docker network can access it on port 5432.
    # If you need direct access from the host for maintenance, ensure your VPS firewall is configured.
    # ports:
    #   - "5432:5432"
    restart: unless-stopped
    networks:
      - app-network
    # Optional: Add a healthcheck for the database
    # healthcheck:
    #   test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}"]
    #   interval: 10s
    #   timeout: 5s
    #   retries: 5

volumes:
  postgres_data: # Defines the named volume for persistent PostgreSQL data
    driver: local # Explicitly state driver (default is local)

networks:
  app-network: # Defines the bridge network for communication between services
    driver: bridge

# The .env file on the VPS (created by your GitHub Action) will provide:
# DB_USER, DB_PASSWORD, DB_NAME, BACKEND_IMAGE_NAME, FRONTEND_IMAGE_NAME
# and any other secrets/configs you add there.
